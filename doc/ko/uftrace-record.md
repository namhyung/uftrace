% UFTRACE-RECORD(1) Uftrace User Manuals
% Namhyung Kim <namhyung@gmail.com>
% Sep, 2018

NAME
====
uftrace-record - Run a command and record its trace data


SYNOPSIS
========
uftrace record [*options*] COMMAND [*command-options*]


DESCRIPTION
===========
This command runs COMMAND and gathers function trace data from it, and saves it
into files under the uftrace data directory - without displaying anything.

This data can then be inspected later on, using `uftrace replay` or
`uftrace report`.


RECORD OPTIONS
==============
-A *SPEC*, \--argument=*SPEC*
:   Record function arguments.  This option can be used more than once.
    Implies \--srcline.  See *ARGUMENTS*.

-R *SPEC*, \--retval=*SPEC*
:   Record function return values.  This option can be used more than once.
    Implies \--srcline.  See *ARGUMENTS*.

-P *FUNC*, \--patch=*FUNC*
:   Patch FUNC dynamically.  This option can be used more than once.
    See *DYNAMIC TRACING*.

-Z *SIZE*, \--size-filter=*SIZE*
:   Patch functions bigger than SIZE bytes dynamically.  See *DYNAMIC TRACING*.

-E *EVENT*, \--event=*EVENT*
:   Enable event tracing.  The event should be available on the system.

-S *SCRIPT_PATH*, \--script=*SCRIPT_PATH*
:   Run a given script to do additional work at the entry and exit of function
    during target program execution.
    The type of script is detected by the postfix such as '.py' for python.
    See *SCRIPT EXECUTION*.

-W, \--watch=*POINT*
:   Add watch point to display POINT if the value is changed.  See *WATCH POINT*.

-a, \--auto-args
:   Automatically record arguments and return values of known functions.
    These are usually functions in standard (C language or system) libraries
    but if debug info is available it includes functions in the user program.
    Implies \--srcline.

-l, \--nest-libcall
:   Trace function calls between libraries.  By default, uftrace only record
    library call from the main executable.  Implies `--force`.

-k, \--kernel
:   Trace kernel functions as well as user functions.  Only kernel entry/exit
    functions will be traced by default.  Use the `--kernel-depth` option to
    override this.

-K *DEPTH*, \--kernel-depth=*DEPTH*
:   Set kernel max function depth separately.  Implies `--kernel`.

-H *HOST*, \--host=*HOST*
:   Send trace data to given host via the network, not writing to files.
    The `uftrace recv` command should be run on the destination host to receive
    the data.

\--port=*PORT*
:   When sending data to the network (with `-H`), use the given port instead of
    the default (8090).

\--signal=*TRG*
:   Set trigger on selected signals rather than functions.  But there are
    restrictions so only a few of trigger actions are support for signals.
    The available actions are: trace_on, trace_off, finish.
    This option can be used more than once.  See *TRIGGERS*.

\--nop
:   Do not record any functions.  This is a no-op and only meaningful for
    performance comparisons.

\--force
:   Allow running uftrace even if some problems occur.  When `uftrace record`
    finds no mcount symbol (which is generated by compiler) in the executable,
    it quits with an error message since uftrace can not trace the program.
    However, it is possible that the user is only interested in functions within
    a dynamically-linked library, in which case this option can be used to cause
    uftrace to run the program regardless.  Also, the `-A`/`--argument` and
    `-R`/`--retval` options work only for binaries built with `-pg`, so uftrace
    will normally exit when it tries to run binaries built without that option.
    This option ignores the warning and goes on tracing without the argument
    and/or return value.

\--time
:   Print running time of children in `time`(1)-style.


COMMON OPTIONS
==============
-F *FUNC*, \--filter=*FUNC*
:   Set filter to trace selected functions only.  This option can be used more
    than once.  See *FILTERS*.

-N *FUNC*, \--notrace=*FUNC*
:   Set filter not to trace selected functions (or the functions called
    underneath them).  This option can be used more than once.  See *FILTERS*.

-C *FUNC*, \--caller-filter=*FUNC*
:   Set filter to trace callers of selected functions only.  This option can be
    used more than once.  See *FILTERS*.

-T *TRG*, \--trigger=*TRG*
:   Set trigger on selected functions.  This option can be used more than once.
    See *TRIGGERS*.

-D *DEPTH*, \--depth=*DEPTH*
:   Set global trace limit in nesting level.  See *FILTERS*.

-t *TIME*, \--time-filter=*TIME*
:   Do not show functions which run under the time threshold.  If some functions
    explicitly have the 'trace' trigger applied, those are always traced
    regardless of execution time.  See *FILTERS*.

\--no-libcall
:   Do not record library function invocations.  Library calls are normally
    traced by hooking the dynamic linker's resolve function in the PLT.
    One can disable it with this option.

\--no-event
:   Disable event recording which is used by default.  Note that explicit event
    tracing by `--event` option is not affected by this.

\--match=*TYPE*
:   Use pattern match using TYPE.  Possible types are `regex` and `glob`.
    Default is `regex`.

\--disable
:   Start uftrace with tracing disabled.  This is only meaningful when used with
    a `trace_on` trigger.



RECORD CONFIG OPTIONS
=====================
-L *PATH*, \--library-path=*PATH*
:   Load necessary internal libraries from this path.  This is mostly for
    testing purposes.

-b *SIZE*, \--buffer=*SIZE*
:   Size of internal buffer in which trace data will be saved.  Default size is
    128k.

\--kernel-buffer=*SIZE*
:   Set kernel tracing buffer size.  The default value (in the kernel) is 1408k.

\--no-pltbind
:   Do not bind dynamic symbol address.  This option uses the `LD_BIND_NOT`
    environment variable to trace library function calls which might be missing
    due to concurrent (first) accesses.  It is not meaningful to use this option
    with the `--no-libcall` option.

\--max-stack=*DEPTH*
:   Set the max function stack depth for tracing.  Default is 1024.

\--num-thread=*NUM*
:   Use NUM threads to record trace data.  Default is 1/4 of online CPUs (but
    when full kernel tracing is enabled, it will use the full number of CPUs).

\--libmcount-single
:   Use single thread version of libmcount for faster recording.  This is
    ignored if the target program links with the pthread library.

\--rt-prio=*PRIO*
:   Boost priority of recording threads to real-time (FIFO) with priority of
    *PRIO*.  This is particularly useful for high-volume data such as full
    kernel tracing.

\--keep-pid
:   Retain same pid for traced program.  For some daemon processes, it is
    important to have same pid when forked.  Running under uftrace normally
    changes pid as it calls fork() again internally.

\--no-randomize-addr
:   Disable ASLR (Address Space Layout Randomization).  It makes the target
    process fix its address space layout.

\--srcline
:   Enable recording source line in the debug info.


필터
=======
uftrace는 관심 대상이 아닌 함수들을 필터링한 결과들을 제공한다.
필터링은 유저들이 관심 있는 함수들에만 집중할 수 있게 하고,
데이터의 크기를 줄이기 때문에 사용이 권장된다.
uftrace가 호출되면, 두 종류의 함수 필터를 갖게 된다;
옵트인 필터로서의 `-F`/`--filter`와 옵트아웃 필터로서의 `-N`/`--notrace`.
이 필터들은 시간을 레코드하거나 리플레이할 떄 적용된다.

첫번째 필터 종류는 옵트인 필터이다. 기본적으로, 이것은 아무것도 추적하지 않는다.
하지만 어떤 명시된 함수가 실행되게 되면, 추적이 시작된다. 그러다 함수가 리턴하게 되면,
추적은 다시 멈추게 된다.   

예를 들어, `a()`, `b()` 와 `c()`를 차례로 호출하는 간단한 프로그램을 생각해보자.

    $ cat abc.c
    void c(void) {
        /* do nothing */
    }

    void b(void) {
        c();
    }

    void a(void) {
        b();
    }

    int main(void) {
        a();
        return 0;
    }

    $ gcc -pg -o abc abc.c

일반적인 경우 uftrace는 `main()`부터 `c()`까지의 모든 함수들을 추적할 것이다.

    $ uftrace live ./abc
    # DURATION    TID     FUNCTION
     138.494 us [ 1234] | __cxa_atexit();
                [ 1234] | main() {
                [ 1234] |   a() {
                [ 1234] |     b() {
       3.880 us [ 1234] |       c();
       5.475 us [ 1234] |     } /* b */
       6.448 us [ 1234] |   } /* a */
       8.631 us [ 1234] | } /* main */

위 예시에서, 명시적으로 `live`명령어가 쓰였다. 하지만 `live`명령어는 기본 명령어이기 때문에
생략해도 무방하다. 따라서 위 명령어는 짧게 `uftrace ./abc`로 사용해도 같은 결과를 낸다.

하지만 `-F b` 필터 옵션이 사용되었을 때는, `main()`과 `a()`함수는 추적되지 않고 오직 `b()`과 `c()`만 
추적될 것이다.

    $ uftrace -F b ./abc
    # DURATION    TID     FUNCTION
                [ 1234] | b() {
       3.880 us [ 1234] |   c();
       5.475 us [ 1234] | } /* b */

두번째 필터 종류는 옵트아웃 필터이다. 기본적으로, 모든 것이 추적되지만,
명시된 함수가 실행되게 되면, 추적을 멈춘다. 제외된 함수가 리턴하게 되면, 추적을 재개한다. 

위 예시에서, `b()`함수와 그의 모든 호출은 `-N`옵션으로 생략할 수 있었다. 

    $ uftrace -N b ./abc
    # DURATION    TID     FUNCTION
     138.494 us [ 1234] | __cxa_atexit();
                [ 1234] | main() {
       6.448 us [ 1234] |   a();
       8.631 us [ 1234] | } /* main */

만일 특정 함수에만 관심이 있고 그 함수가 어떻게 호출되는지만 알고 싶다면,
caller filter를 사용하면 될 것이다. 그 함수를 leaf로 만들고,
그 함수의 모든 부모 함수들을 레코드한다.

    $ uftrace -C b ./abc
    # DURATION    TID     FUNCTION
                [ 1234] | main() {
                [ 1234] |   a() {
       5.475 us [ 1234] |     b();
       6.448 us [ 1234] |   } /* a */
       8.631 us [ 1234] | } /* main */

위 예시에서, 호출 경로에 없는 함수들을 출력되지 않았다. 또한, 함수 `b()`의 자식 함수인 
함수 `c()`또한 출력되지 않았다. 

또한, `-D`옵션으로 함수의 중첩 깊이을 제한할 수도 있다.

    $ uftrace -D 3 ./abc
    # DURATION    TID     FUNCTION
     138.494 us [ 1234] | __cxa_atexit();
                [ 1234] | main() {
                [ 1234] |   a() {
       5.475 us [ 1234] |     b();
       6.448 us [ 1234] |   } /* a */
       8.631 us [ 1234] | } /* main */

위 예시에서, uftrace는 함수 호출 깊이를 최대 3으로 제한하여 출력했기 때문에,
leaf 함수인 `c()`는 생략되었다. `-D`옵션이 `-F`옵션과 함께 쓰일 수 있음에 유의하라.

때로는, 장시간 실행되는 함수를 관찰하는 것이 유용하다. 
이는 작은 (실행시간을 가지는) 함수들 중에는 관심 대상이 아닌 것들이 많기 때문이다.
`-t`/`--time-filter`옵션은 명시된 임계시간보다 오래 실행된 함수들만 레코드할 수 있게 하는
시간 기반 필터이다. 위 예시에서는, 사용자는 대부분 아래와 같이 5마이크로 초 이상 동안 
실행되는 함수를 보고 싶어할 것이다:

    $ uftrace -t 5us ./abc
    # DURATION    TID     FUNCTION
     138.494 us [ 1234] | __cxa_atexit();
                [ 1234] | main() {
                [ 1234] |   a() {
       5.475 us [ 1234] |     b();
       6.448 us [ 1234] |   } /* a */
       8.631 us [ 1234] | } /* main */

필터링된 함수에 트리거를 설정할 수도 있다. 더 많은 정보를 확인하기 위해 *TRIGGERS* 항목을
참고한다.

커널함수 추적을 설정하면, `@kernel` 식별자를 통해 커널 함수에 대한 필터를 적용할 수 있다.
이하 예시에서는 모든 유저 함수와 (커널 레벨의) page fault 핸들러들을 보여준다.

    $ sudo uftrace -k -F '.*page_fault@kernel' ./abc
    # DURATION    TID     FUNCTION
               [14721] | main() {
      7.713 us [14721] |   __do_page_fault();
      6.600 us [14721] |   __do_page_fault();
      6.544 us [14721] |   __do_page_fault();
               [14721] |   a() {
               [14721] |     b() {
               [14721] |       c() {
      0.860 us [14721] |         getpid();
      2.346 us [14721] |       } /* c */
      2.956 us [14721] |     } /* b */
      3.340 us [14721] |   } /* a */
     79.086 us [14721] | } /* main */


트리거
========
uftrace 도구는 선택된 함수 호출(필터가 있든 없든)과 
시그널에 대한 트리거 동작을 지원한다.
현재 지원되는 트리거와 사양에 대한 BNF는 다음과 같다.

    <trigger>    :=  <symbol> "@" <actions>
    <actions>    :=  <action>  | <action> "," <actions>
    <action>     :=  "depth="<num> | "backtrace" | "trace" | "trace_on" | "trace_off" |
                     "recover" | "color="<color> | "time="<time_spec> | "read="<read_spec> |
                     "finish" | "filter" | "notrace"
    <time_spec>  :=  <num> [ <time_unit> ]
    <time_unit>  :=  "ns" | "nsec" | "us" | "usec" | "ms" | "msec" | "s" | "sec" | "m" | "min"
    <read_spec>  :=  "proc/statm" | "page-fault" | "pmu-cycle" | "pmu-cache" | "pmu-branch"

`depth` 트리거는 함수를 실행하는 동안 필터 깊이를 변경한다.
다양한 함수에 대해 서로 다른 필터 깊이를 설정할 수 있다.
그리고 `backtrace` 트리거는 replay 시 스택 역추적을 출력한다.

색깔 트리거는 재생 명령어에서 색상을 변경한다.
지원되는 색상은 `red`, `green`, `blue`, `yellow`, `magenta`, `cyan`,`bold`,`gray`. 등이 있다.

다음 예제는 트리거 작동 방식을 보여준다. 전역 필터 깊이가 5로 설정되어 있지만
`b()` 함수에 `depth` 트리거를 설정하여 `b()` 아래 함수는 보이지 않게된다.

    $ uftrace -D 5 -T 'b@depth=1' ./abc
    # DURATION    TID     FUNCTION
     138.494 us [ 1234] | __cxa_atexit();
                [ 1234] | main() {
                [ 1234] |   a() {
       5.475 us [ 1234] |     b();
       6.448 us [ 1234] |   } /* a */
       8.631 us [ 1234] | } /* main */

`backtrace` 트리거는 replay에서만 사용할 수 있다.

`trace_on`과 `trace_off` 트리거는 uftrace가 지정된 함수를 기록할지 여부를 관리한다.
또한, `_` 문자 없이 `traceon`과 `traceoff`로도 사용할 수있다.

`recover` 트리거는 프로세스가 콜스택에 직접 접근하는 일부 경우에 사용된다.
예를들어, v8 자바스크립트 엔진을 추적하는 동안 가비지 수집 단계에서 segfaults 
문제가 발생된다면 이는 v8이 (변경된) 반환 주소를 통해 컴파일된 코드 객체에 접근하려 하기 때문이다.
`recover` 트리거는 함수 시작점에 원래 반환 주소를 복원하고 기능 종료 시 
다시 uftrace 리턴 주소로 재설정한다. (특히 v8 자바스크립트 엔진 사례에서 `ExitFrame::Iterate` 
함수와 같이 문제를 발생시키는 상황에서 `recover` 사용하면 문제를 해결할 수 있다.)


`time` 트리거는 함수를 실행하는 동안 시간 필터 설정을 변경한다.
다른 함수들에 대해서 다른 시간 필터를 적용할 떄 사용할 수 있다.

`read` 트리거는 실행 시에 일부 정보를 읽을 수 있다. 
결과는 주어진 함수의 시작과 끝에 (내장) 이벤트의 형태로 기록된다.
현재는 다음과 같은 이벤트가 지원되고 있다.

 * "proc/statm": /proc 파일시스템에서 메모리 통계 처리 
 * "page-fault": getrusage(2)를 사용한 페이지 결함 수
 * "pmu-cycle":  Linux perf-event 시스템콜을 통한 cpu 클럭 사이클 및 명령어 실행 횟수
 * "pmu-cache":  (cpu) Linux Perfect-Event syscall을 사용한 캐시 참조 및 누락 
 * "pmu-branch": Linux Perfect-Event syscall을 사용한 분기 지침 및 누락
 
결과는 아래와 같이 이벤트(코멘트)로 출력된다.

    $ uftrace -T a@read=proc/statm ./abc
    # DURATION    TID     FUNCTION
                [ 1234] | main() {
                [ 1234] |   a() {
                [ 1234] |     /* read:proc/statm (size=6808KB, rss=776KB, shared=712KB) */
                [ 1234] |     b() {
                [ 1234] |       c() {
       1.448 us [ 1234] |         getpid();
      10.270 us [ 1234] |       } /* c */
      11.250 us [ 1234] |     } /* b */
                [ 1234] |     /* diff:proc/statm (size=+4KB, rss=+0KB, shared=+0KB) */
      18.380 us [ 1234] |   } /* a */
      19.537 us [ 1234] | } /* main */


`finish` 트리거는 기록을 종료할 떄 사용한다. 데몬과 같이 종료되지 
않는 프로세스를 추적하는 데 유용할 수 있다.

`filter` 와 `notrace` 트리거는 각각 `-F`/`--filter`와 `-N` /`--notrace` 같은 효과가 있다.

트리거는 현재 유저 레벨 함수들에서만 동작한다.

트리거는 시그널에도 사용할 수 있다. `signal` 트리거에 의해 수행되며
`\--signal option` 옵션으로 함수 트리거와 비슷하지만
현재는 "trace_on", "trace_off" 및 "finish"트리거만 지원되고 있다.

    $ uftrace --signal 'SIGUSR1@finish' ./some-daemon


인자
=========
uftrace는 함수의 인자와 리턴값을 각각 -A/\--argument와 -R/\--retval로 레코딩할 수 있다.
이 문법체계는 트리거의 그것과 매우 유사하다:

    <argument>    :=  <symbol> [ "@" <specs> ]
    <specs>       :=  <spec> | <spec> "," <spec>
    <spec>        :=  ( <int_spec> | <float_spec> | <ret_spec> )
    <int_spec>    :=  "arg" N [ "/" <format> [ <size> ] ] [ "%" ( <reg> | <stack> ) ]
    <float_spec>  :=  "fparg" N [ "/" ( <size> | "80" ) ] [ "%" ( <reg> | <stack> ) ]
    <ret_spec>    :=  "retval" [ "/" <format> [ <size> ] ]
    <format>      :=  "d" | "i" | "u" | "x" | "s" | "c" | "f" | "S" | "p"
    <size>        :=  "8" | "16" | "32" | "64"
    <reg>         :=  <arch-specific register name>  # "rdi", "xmm0", "r0", ...
    <stack>       :=  "stack" [ "+" ] <offset>

-A/\--argument옵션은 symbol의 이름과 그것의 spec들을 선택적으로 받는다.
spec은 argN으로 시작되는데 여기서 N은 인자의 인덱스값이다.
인덱스는 1부터 시작되며, 순서는 시스템 호출 관례의 인자 전달 순서와 상응한다. 
인자의 인덱스는 정수형 (혹은 포인터형) 과 부동소수점형 각각 따로 세어진다는 점, 그리고 
그것들은 호출 관례에 따라 각기 간섭을 일으킬 수 있다는 점에 유의하라.
argN은 정수형 인자를, fpargN은 부동소수점형 인자를 위한 표기이다.

"d" 형식 혹은 아무 형식도 주지 않을 경우, uftrace는 정수형은 'long int'형으로 
간주하고 소수형에 대해서는 'double'형으로 간주한다.

"i" 형식은 signed 정수형으로, "u" 형식은 unsinged으로 출력한다.
두 형식 모두 10진수가 출력되는 한편 "x" 형식은 16진수로 출력되게 한다.
"s"는 null을 제외한 문자열 출력을 위한 형식이고, "c"는 단일 문자를 위한 형식이다.
"f" 형식은 부동 소수점을 출력하는데, (일반적으로) 리턴 값에서만 의미를 가진다. 

fpargN은 항상 소수점 방식이기 때문에 어떤 형식 필드도 없음에 유의하라.
"S" 형식은 std::string을 위한 형식이지만, 아직까지는 libstdc++ 라이브러리만 지원가능하다.
마지막으로, "p" 형식은 함수포인터 형식이다. 추적 대상의 주소가 레코드 되면, 언제나 함수 이름으로 
출력된다.

문자형 타입의 인자를 사용할 때 (포인터) 값이 유효하지 않을 경우 프로그램을 중단시킬 수 있음에 주의하라.
사실 uftrace는 유효한 프로세스 주소 공간의 범위를 지속적으로 추적하려 노력하지만, 
몇몇 코너 케이스들을 놓칠 수 있다.

또한 특정 레지스터의 이름이나 스택 오프셋도 인자로 명시할 수 있다 (리턴 값은 불가하다). 
이하 레지스터 이름들이 인자로 쓰일 수 있는 레지스터 이름들이다:

 * x86: rdi, rsi, rdx, rcx, r8, r9 (for integer), xmm[0-7] (for floating-point)
 * arm: r[0-3] (for integer), s[0-15] or d[0-7] (for floating-point)

예시는 아래와 같다:

    $ uftrace -A main@arg1/x -R main@retval/i32 ./abc
    # DURATION    TID     FUNCTION
     138.494 us [ 1234] | __cxa_atexit();
                [ 1234] | main(0x1) {
                [ 1234] |   a() {
                [ 1234] |     b() {
       3.880 us [ 1234] |       c();
       5.475 us [ 1234] |     } /* b */
       6.448 us [ 1234] |   } /* a */
       8.631 us [ 1234] | } = 0; /* main */

    $ uftrace -A puts@arg1/s -R puts@retval ./hello
    Hello world
    # DURATION    TID     FUNCTION
       1.457 us [21534] | __monstartup();
       0.997 us [21534] | __cxa_atexit();
                [21534] | main() {
       7.226 us [21534] |   puts("Hello world") = 12;
       8.708 us [21534] | } /* main */

이 인자들과 리턴값들은 실행파일이 `-pg`옵션으로 빌드되었을 때에만 레코드됨에 유의하라.
`-finstrument-functions`로 만들어진 실행파일들은 라이브러리 호출을 제외하고는 무시된다.
인자와 리턴값의 레코드는 아직까진 사용자 정의 함수에서만 동작한다.

만일 프로그램이 DWARF와 같은 디버그 정보와 함께 빌드되었다면, uftrace는 (libdw로 빌드되었다면) 자동으로  
인자들의 갯수와 자료형들을 식별할 수 있다. 또한 디버그 정보를 사용하지 않더라도, 몇몇 잘 알려진 
라이브러리 함수들의 인자들과 리턴값은 기본적으로 제공된다. 
이 경우 사용자는 인자들의 spec과 리턴값을 수동적으로 명시할 필요가 없다 - 그저 함수의 이름 (또는 패턴) 만 
주는 것으로도 충분하다. 사실, 명시적으로 argspec 을 지정하면 자동 argspec을 표시되지 않게 한다. 

예를 들어, 위 예시는 아래와 같이 작성할 수 있다.

    $ uftrace -A . -R main -F main ./hello
    Hello world
    # DURATION     TID     FUNCTION
                [ 18948] | main(1, 0x7ffeeb7590b8) {
       7.183 us [ 18948] |   puts("Hello world");
       9.832 us [ 18948] | } = 0; /* main */

인자 패턴 (".")은 모든 문자에 대응되기 때문에 모든 (지원되는) 함수들이 레코드 되었음에 유의하라.
"main"함수의 두 인자들과 "puts"의 한 문자열 인자를 보여준다.
만일 모든 (지원되는) 함수의 모든 인자들과 리턴값들을 보고 싶다면, -a/\--auto-args 옵션을 사용하라.


동적 추적
===============
uftrace는 x86_64, AArch64환경의 런타임 (정확하게는, 로드타임) 에서 동적인 함수 추적이 가능하다.
함수를 레코드하기 전에, 보통 프로그램을 `-pg` (혹은
`-finstrument-functions`으로) 빌드해야 하고, 그렇게 된다면 모든 함수들이 `mcount()`를
호출하기 때문에 어느 정도 성능에 영향을 받게 될 것이다.

동적인 추적을 할 때, `-P`/`--patch` 옵션을 통해 특정 함수만을 추적할 수 있다.
capstone disassembly engine을 사용한다면 위 옵션을 지정해서 프로그램을 (재)컴파일할 필요가 없다.

이제 uftrace는 명령어들을 분석할 수 있게 되고 (만약 가능하다면) 그 명령어들을 
다른 곳에 복사하여 `mcount()`함수들을 호출하여 uftrace로 추적할 수 있게 rewrite 할 수 있다.
그 이후 제어권은 복사된 명령어로 넘어가게 되고, 그 다음에야 남은 명령어들로 리턴하게 된다.

capstone을 사용할 수 없다면, 프로그램을 빌드할 때 몇몇 컴파일러 (gcc) 옵션들을 추가해야 할 것이다.
gcc 5.1 버전 이상부터 `-mfentry`와 `-mnop-mcount`옵션을 제공하는데 
이 옵션들은 함수 맨 앞에 인스트루먼테이션 (이를테면, `mcount()` 함수를 호출하는) 코드를 추가하고 
그 명령어를 NOP로 변환한다. 그렇게 되면 정상적인 조건에서 실행한다면 성능 상의 오버헤드가 거의 없어질 것이다.
uftrace는 `-P`옵션을 이용하여 선택적으로 `mcount()`함수를 호출할 수 있게 전환할 수 있다.

uftrace를 이하 예제에서 평소처럼 사용한다면 에러 메세지를 띄운다.
그 이유는 바이너리가 어떤 인스트루먼테이션 코드 (이를테면 `mcount()`함수)도 호출하지 않기 때문이다.

    $ gcc -o abc -pg -mfentry -mnop-mcount tests/s-abc.c
    $ uftrace abc
    uftrace: /home/namhyung/project/uftrace/cmd-record.c:1305:check_binary
      ERROR: Can't find 'mcount' symbol in the 'abc'.
             It seems not to be compiled with -pg or -finstrument-functions flag
             which generates traceable code.  Please check your binary file.

하지만 `-P a` 패치 옵션을 적용한다면, 동적으로 `a()` 함수만을 추적할 것이다. 

    $ uftrace --no-libcall -P a abc
    # DURATION    TID     FUNCTION
       0.923 us [19379] | a();

추가로, '.'을 이용해 (glob은, '*') `P`옵션과 함께 정규표현식으로 쓰인 문자에 대해  
하나라도 매칭되는 모든 함수들에 대해서도 적용시킬 수 있다.

    $ uftrace --no-libcall -P . abc
    # DURATION    TID     FUNCTION
                [19387] | main() {
                [19387] |   a() {
                [19387] |     b() {
       0.940 us [19387] |       c();
       2.030 us [19387] |     } /* b */
       2.451 us [19387] |   } /* a */
       3.289 us [19387] | } /* main */

Clang/LLVM 4.0은 [X-ray](http://llvm.org/docs/XRay.html)라는 동적인 인스트루먼테이션 기술을 제공한다.
이는 `gcc -mfentry -mnop-mcount`와 `-finstrument-functions`를 결합한 것과도 유사하다.
uftrace는 `X-ray`로 빌드된 실행파일에 대해서도 동적인 추적을 지원한다.

예를 들어, 대상 프로그램을 clang으로 아래의 옵션으로 빌드할 수도 있지만,
그와 동일하게 동적인 추적을 위해 아래와 같이 `-P`옵션을 사용할 수도 있을 것이다:

    $ clang -fxray-instrument -fxray-instruction-threshold=1 -o abc-xray  tests/s-abc.c
    $ uftrace -P main abc-xray
    # DURATION    TID     FUNCTION
                [11093] | main() {
       1.659 us [11093] |   getpid();
       5.963 us [11093] | } /* main */

    $ uftrace -P . abc-xray
    # DURATION    TID     FUNCTION
                [11098] | main() {
                [11098] |   a() {
                [11098] |     b() {
                [11098] |       c() {
       0.753 us [11098] |         getpid();
       1.430 us [11098] |       } /* c */
       1.915 us [11098] |     } /* b */
       2.405 us [11098] |   } /* a */
       3.005 us [11098] | } /* main */


스크립트 실행
================
uftrace는 함수의 진입과 종료를 보여주는 스크립트 실행을 지원한다.
지원되는 스크립트는 아직까지는 Python 2.7 뿐이다.

사용자는 네 개의 함수를 쓸 수 있다. 'uftrace_entry'와 'uftracce_exit'은 
각 함수가 진입과 종료시기에서 실행 중이라면 언제든 실행된다.
하지만 'uftrace_begin'과 'uftrace_end'는 분석 대상 프로그램이 시작되고 끝날 때 한 번씩만 실행된다.

    $ cat scripts/simple.py
    def uftrace_begin(ctx):
        print("program begins...")

    def uftrace_entry(ctx):
        func = ctx["name"]
        print("entry : " + func + "()")

    def uftrace_exit(ctx):
        func = ctx["name"]
        print("exit  : " + func + "()")

    def uftrace_end():
        print("program is finished")

위 스크립트는 아래와 같이 레코드 시간 순으로 실행될 수 있다:

    $ uftrace -S scripts/simple.py -F main tests/t-abc
    program begins...
    entry : main()
    entry : a()
    entry : b()
    entry : c()
    entry : getpid()
    exit  : getpid()
    exit  : c()
    exit  : b()
    exit  : a()
    exit  : main()
    program is finished
    # DURATION    TID     FUNCTION
                [10929] | main() {
                [10929] |   a() {
                [10929] |     b() {
                [10929] |       c() {
       4.293 us [10929] |         getpid();
      19.017 us [10929] |       } /* c */
      27.710 us [10929] |     } /* b */
      37.007 us [10929] |   } /* a */
      55.260 us [10929] | } /* main */

'ctx'변수는 아래의 정보를 포함하는 딕셔너리 변수이다.

    /* context information passed to uftrace_entry(ctx) and uftrace_exit(ctx) */
    script_context = {
        int       tid;
        int       depth;
        long      timestamp;
        long      duration;    # exit only
        long      address;
        string    name;
        list      args;        # entry only (if available)
        value     retval;      # exit  only (if available)
    };

    /* context information passed to uftrace_begin(ctx) */
    script_context = {
        bool      record;      # True if it runs at record time, otherwise False
        string    version;     # uftrace version info
        list      cmds;        # execution commands
    };

'script_context'에 있는 각 필드들은 스크립트 내에서 읽을 수 있다.
스크립팅에 대한 자세한 사항은 `uftrace-script`(1)를 참고할 것.


조사식
===========
uftrace의 watch point는 특정 값의 변경사항을 출력한다. 개념적으로는 디버거의 watch point와 같지만,
함수의 진입과 종료에만 적용되기 때문에 몇몇 변경사항들은 놓칠 수도 있다.

아직까지는, 아래의 watch point들이 지원된다:

 * "cpu" : 현재 작업을 수행하는 cpu 번호

트리거를 읽을 때처럼, 결과는 이벤트로서 (주석으로) 출력된다:

    $ uftrace -W cpu tests/t-abc
    # DURATION     TID     FUNCTION
                [ 19060] | main() {
                [ 19060] |   /* watch:cpu (cpu=8) */
                [ 19060] |   a() {
                [ 19060] |     b() {
                [ 19060] |       c() {
       2.365 us [ 19060] |         getpid();
       8.002 us [ 19060] |       } /* c */
       8.690 us [ 19060] |     } /* b */
       9.350 us [ 19060] |   } /* a */
      12.479 us [ 19060] | } /* main */


함께 보기
========
`uftrace`(1), `uftrace-replay`(1), `uftrace-report`(1), `uftrace-recv`(1), `uftrace-graph`(1), `uftrace-script`(1), `uftrace-tui`(1)


번역자
======
강민철 <tegongkang@gmail.com>